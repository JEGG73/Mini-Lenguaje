package Analizador;

import java_cup.runtime.Symbol;
import java.util.List;
import java.util.LinkedList;

parser code {:
    // Lista para almacenar los errores sintácticos encontrados
    private List<String> syntaxErrors = new LinkedList<>();

    // Método mejorado para reportar errores sintácticos con línea y columna
    public void syntax_error(Symbol cur_token) {
        String errorMsg = String.format(
            "Error Sintáctico en línea %d, columna %d: Token inesperado '%s'",
            cur_token.left + 1,
            cur_token.right + 1,
            cur_token.value != null ? cur_token.value : sym.terminalNames[cur_token.sym]
        );
        throw new RuntimeException(errorMsg);
        syntaxErrors.add(errorMsg);
    }

    public void report_error(String message, Object info) {
        syntaxErrors.add("Error Sintáctico: " + message);
    }
    
    public List<String> getSyntaxErrors() {
        return syntaxErrors;
    }

    private Symbol lastErrorSymbol;
    public Symbol getLastErrorSymbol() {
        return lastErrorSymbol;
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        lastErrorSymbol = cur_token;
        syntaxErrors.add(String.format(
            "Error sintáctico irrecuperable en línea %d, columna %d: Token '%s'",
            cur_token.left + 1,
            cur_token.right + 1,
            cur_token.value != null ? cur_token.value : sym.terminalNames[cur_token.sym]
        ));
    }
:};

// --- Terminales (Limpiando los no usados) ---
terminal INICIO_PROGRAMA, FIN_PROGRAMA, PUBLICO, PRIVADO, PROTEGIDO,
    ESTATICO, FUNCION, RETORNO, IF, ELSE, WHEN, FOR, WHILE, DO, TIPO_STRING, TIPO_CHAR,
    TIPO_INT, TIPO_FLOAT, TIPO_DOUBLE, TIPO_BOOLEAN, ENTRADA, IMPRIMIR, IMPRIMIR_CON_SALTO,
    TRUE, FALSE, NEW, MAYOR_QUE, MENOR_QUE, IGUAL_A, DIFERENTE_DE, MAYOR_IGUAL, MENOR_IGUAL, AND, OR, NEGACION,
    SUMA, RESTA, MULTIPLICACION, DIVISION, MODULO, ASIGNACION_VALOR, OPERADOR_INCREMENTO, OPERADOR_DECREMENTO,
    SUMA_Y_ASIGNACION, RESTA_Y_ASIGNACION, MULTIPLICACION_Y_ASIGNACION, DIVISION_Y_ASIGNACION, MODULO_Y_ASIGNACION,
    IDENTIFICADOR, NUMERO_ENTERO, NUMERODECIMAL, CADENA, CARACTER, PARENTESIS_APERTURA, PARENTESIS_CIERRE,
    CORCHETE_APERTURA, CORCHETE_CIERRE, LLAVE_APERTURA, LLAVE_CIERRE, DOS_PUNTOS, PUNTO_COMA,
    COMENTARIO, COMENTARIO_MULTILINEA, COMA, ERROR;
terminal IFX; // Terminal "fantasma" para precedencia

// --- No Terminales ---
non terminal INICIO, LISTA_SENTENCIAS, SENTENCIA, BLOQUE_SENTENCIAS;
non terminal DECLARACION, TIPO, INICIALIZADOR_ARREGLO, LISTA_EXPRESIONES;
non terminal ESTRUCTURA_IF, ESTRUCTURA_WHEN, ESTRUCTURA_WHILE, ESTRUCTURA_DO_WHILE, ESTRUCTURA_FOR;
non terminal INICIALIZACION_FOR, ACTUALIZACION_FOR;
non terminal DEFINICION_FUNCION, LISTA_PARAMETROS, PARAMETRO, TIPO_RETORNO, MODIFICADORES;
non terminal EXPRESION, LISTA_ARGUMENTOS;
non terminal CUERPO_WHEN, CASO_WHEN, LISTA_CASOS_WHEN;

// --- Precedencia y Asociatividad ---
precedence right ASIGNACION_VALOR, SUMA_Y_ASIGNACION, RESTA_Y_ASIGNACION, MULTIPLICACION_Y_ASIGNACION, DIVISION_Y_ASIGNACION, MODULO_Y_ASIGNACION;
precedence left OR;
precedence left AND;
precedence nonassoc IGUAL_A, DIFERENTE_DE;
precedence nonassoc MENOR_QUE, MAYOR_QUE, MENOR_IGUAL, MAYOR_IGUAL;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right NEGACION;
// Solución "dangling else"
precedence nonassoc IFX;
precedence nonassoc ELSE;

start with INICIO;

// --- Reglas Gramaticales ---
INICIO ::= INICIO_PROGRAMA IDENTIFICADOR BLOQUE_SENTENCIAS FIN_PROGRAMA IDENTIFICADOR;

BLOQUE_SENTENCIAS ::= LLAVE_APERTURA LISTA_SENTENCIAS LLAVE_CIERRE | LLAVE_APERTURA LLAVE_CIERRE;
LISTA_SENTENCIAS ::= LISTA_SENTENCIAS SENTENCIA | SENTENCIA;
    
SENTENCIA ::= 
    BLOQUE_SENTENCIAS
    | DECLARACION 
    | ESTRUCTURA_IF 
    | ESTRUCTURA_WHEN 
    | ESTRUCTURA_WHILE 
    | ESTRUCTURA_DO_WHILE 
    | ESTRUCTURA_FOR 
    | DEFINICION_FUNCION 
    | COMENTARIO 
    | COMENTARIO_MULTILINEA
    | RETORNO EXPRESION PUNTO_COMA
    | EXPRESION PUNTO_COMA  // Cubre asignaciones, i++, llamadas a función
    | PUNTO_COMA
    | error PUNTO_COMA {: parser.report_error("Sentencia inválida omitida", null); :}
    | ERROR PUNTO_COMA // Manejo de error léxico
    ;

EXPRESION ::=
    EXPRESION ASIGNACION_VALOR EXPRESION
    | EXPRESION SUMA_Y_ASIGNACION EXPRESION | EXPRESION RESTA_Y_ASIGNACION EXPRESION
    | EXPRESION MULTIPLICACION_Y_ASIGNACION EXPRESION | EXPRESION DIVISION_Y_ASIGNACION EXPRESION
    | EXPRESION MODULO_Y_ASIGNACION EXPRESION | EXPRESION OR EXPRESION
    | EXPRESION AND EXPRESION | EXPRESION IGUAL_A EXPRESION
    | EXPRESION DIFERENTE_DE EXPRESION | EXPRESION MAYOR_QUE EXPRESION
    | EXPRESION MENOR_QUE EXPRESION | EXPRESION MAYOR_IGUAL EXPRESION
    | EXPRESION MENOR_IGUAL EXPRESION | EXPRESION SUMA EXPRESION
    | EXPRESION RESTA EXPRESION | EXPRESION MULTIPLICACION EXPRESION
    | EXPRESION DIVISION EXPRESION | EXPRESION MODULO EXPRESION
    | NEGACION EXPRESION
    | OPERADOR_INCREMENTO IDENTIFICADOR | OPERADOR_DECREMENTO IDENTIFICADOR
    | IDENTIFICADOR OPERADOR_INCREMENTO | IDENTIFICADOR OPERADOR_DECREMENTO
    | IDENTIFICADOR
    | NUMERO_ENTERO | NUMERODECIMAL | CADENA | CARACTER | TRUE | FALSE
    | PARENTESIS_APERTURA EXPRESION PARENTESIS_CIERRE
    // --- NUEVO: Llamada a función y acceso a arreglo ---
    | IDENTIFICADOR PARENTESIS_APERTURA LISTA_ARGUMENTOS PARENTESIS_CIERRE
    | IDENTIFICADOR PARENTESIS_APERTURA PARENTESIS_CIERRE
    | ENTRADA PARENTESIS_APERTURA EXPRESION PARENTESIS_CIERRE
    | IDENTIFICADOR CORCHETE_APERTURA EXPRESION CORCHETE_CIERRE
    | IMPRIMIR PARENTESIS_APERTURA EXPRESION PARENTESIS_CIERRE
    | IMPRIMIR_CON_SALTO PARENTESIS_APERTURA EXPRESION PARENTESIS_CIERRE
    ;

// --- NUEVO: Lista de argumentos para llamada a función ---
LISTA_ARGUMENTOS ::= LISTA_ARGUMENTOS COMA EXPRESION | EXPRESION;

DECLARACION ::= 
    TIPO IDENTIFICADOR PUNTO_COMA 
    | TIPO IDENTIFICADOR ASIGNACION_VALOR EXPRESION PUNTO_COMA
    // --- Declaración de arreglos --- 
    // int arr[];
    | TIPO IDENTIFICADOR CORCHETE_APERTURA CORCHETE_CIERRE PUNTO_COMA
    // int[] arr;
    | TIPO CORCHETE_APERTURA CORCHETE_CIERRE IDENTIFICADOR PUNTO_COMA
    // int arr[] = {1, 2};
    | TIPO IDENTIFICADOR CORCHETE_APERTURA CORCHETE_CIERRE ASIGNACION_VALOR INICIALIZADOR_ARREGLO PUNTO_COMA
    // int[] arr = new int[5];
    | TIPO CORCHETE_APERTURA CORCHETE_CIERRE IDENTIFICADOR ASIGNACION_VALOR NEW TIPO CORCHETE_APERTURA EXPRESION CORCHETE_CIERRE PUNTO_COMA
    ;

// --- NUEVO: Inicializador de arreglos: { expr1, expr2, ... } ---
INICIALIZADOR_ARREGLO ::= LLAVE_APERTURA LISTA_EXPRESIONES LLAVE_CIERRE;
LISTA_EXPRESIONES ::= LISTA_EXPRESIONES COMA EXPRESION | EXPRESION;


ESTRUCTURA_IF ::= 
    IF PARENTESIS_APERTURA EXPRESION PARENTESIS_CIERRE SENTENCIA ELSE SENTENCIA
    | IF PARENTESIS_APERTURA EXPRESION PARENTESIS_CIERRE SENTENCIA %prec IFX
    ;

ESTRUCTURA_WHEN ::= WHEN PARENTESIS_APERTURA EXPRESION PARENTESIS_CIERRE LLAVE_APERTURA CUERPO_WHEN LLAVE_CIERRE;
CUERPO_WHEN ::= LISTA_CASOS_WHEN | LISTA_CASOS_WHEN ELSE DOS_PUNTOS SENTENCIA | /* vacío */;
LISTA_CASOS_WHEN ::= CASO_WHEN | LISTA_CASOS_WHEN CASO_WHEN;
CASO_WHEN ::= EXPRESION DOS_PUNTOS SENTENCIA;

ESTRUCTURA_WHILE ::= WHILE PARENTESIS_APERTURA EXPRESION PARENTESIS_CIERRE BLOQUE_SENTENCIAS;
ESTRUCTURA_DO_WHILE ::= DO BLOQUE_SENTENCIAS WHILE PARENTESIS_APERTURA EXPRESION PARENTESIS_CIERRE PUNTO_COMA;

// --- REGLA 'FOR' CORREGIDA ---
ESTRUCTURA_FOR ::= FOR PARENTESIS_APERTURA INICIALIZACION_FOR PUNTO_COMA EXPRESION PUNTO_COMA ACTUALIZACION_FOR PARENTESIS_CIERRE BLOQUE_SENTENCIAS;

// La inicialización es una declaración SIN punto y coma, o una expresión, o vacío
INICIALIZACION_FOR ::= TIPO IDENTIFICADOR ASIGNACION_VALOR EXPRESION | EXPRESION | /* vacio */;

// La actualización puede ser cualquier expresión (como i++ o i = i + 2)
ACTUALIZACION_FOR ::= EXPRESION | /* vacio */;

// --- Reglas de Funciones ---
DEFINICION_FUNCION ::= MODIFICADORES FUNCION IDENTIFICADOR PARENTESIS_APERTURA LISTA_PARAMETROS PARENTESIS_CIERRE TIPO_RETORNO BLOQUE_SENTENCIAS
    | MODIFICADORES FUNCION IDENTIFICADOR PARENTESIS_APERTURA /* sin params */ PARENTESIS_CIERRE TIPO_RETORNO BLOQUE_SENTENCIAS
    ;
MODIFICADORES ::= PUBLICO ESTATICO | PRIVADO ESTATICO | PROTEGIDO ESTATICO | PUBLICO | PRIVADO | PROTEGIDO | ESTATICO | /* vacio */;
LISTA_PARAMETROS ::= PARAMETRO | LISTA_PARAMETROS COMA PARAMETRO;
// --- CORREGIDO: Sintaxis de parámetros con dos puntos ---
PARAMETRO ::= TIPO DOS_PUNTOS IDENTIFICADOR;

TIPO ::= TIPO_INT | TIPO_DOUBLE | TIPO_FLOAT | TIPO_STRING | TIPO_CHAR | TIPO_BOOLEAN;
TIPO_RETORNO ::= DOS_PUNTOS TIPO | /* void */;